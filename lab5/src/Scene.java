import java.awt.Color;import java.util.ArrayList;/** * Scene - the list of items that make up a scene. *  * Eric McCreath 2009, 2019 * @author Xiran Yan * @UID  u7167582 *///todo issue may cause by int/intpublic class Scene extends ArrayList<Item> {	Color background = Color.blue;	P3D lightpos =  new P3D(25.0,30.0,-40.0);	Color lightColor=Color.white;	Sphere lightSphere=new Sphere(lightpos,0.1,lightColor);	float shininess= (float) 50.0;//set up the light shiniess	P3D initAmbient = new P3D(0.3, 0.3, 0.3);       //set up the coefficient  of ambient	P3D vAmbient=initAmbient;	P3D initDiffuse = new P3D(0.7, 0.7, 0.7);       //set up the coefficient  of diffuse	P3D initSpecular =new P3D(0.6, 0.6, 0.6);      //set up the coefficient  of specular	boolean mirror=false;	public Color raytrace(Ray r) {		Double mindis = null;		Intersect intersect = null;		Intersect mirrorintersect = null;		mirror=false;		for (Item s : this) {			Intersect i = s.intersect(r);			//show the closest object			if (i != null) {				if (intersect == null || i.distance < mindis) {					mindis = i.distance;					intersect = i;					if (s.mirror) {						mirror=true;						mirrorintersect=i;					}				}			}		}		if (intersect != null) {			//the closest mirror object			if (mirror&&mirrorintersect==intersect) {				Ray reflect=new Ray(mirrorintersect.hitPosition,mirrorintersect.hitNormal.reflect(r.direction).scale(-1));				return raytrace(reflect);			}			return illuminateCalculate(intersect,r);		}		else {			return background;		}	}	//for rays back to light	public Color shadowRaytrace(Ray r,Intersect originintersect) {		Double mindis = null;		Intersect intersect = null;		for (Item s : this) {			Intersect i = s.intersect(r);			//can't not be in one item			if (i != null) {				if (!i.item.equals(originintersect.item)&&(intersect == null || i.distance < mindis)) {					mindis = i.distance;					intersect = i;				}			}		}		if (intersect != null) {			//calculate the shadow rgb			int new_r=originintersect.color.getRed()/12+Color.black.getRed()*11/12;			int new_g=originintersect.color.getRed()/12+Color.black.getRed()*11/12;			int new_b=originintersect.color.getRed()/12+Color.black.getRed()*11/12;			return new Color(new_r,new_g,new_b);		} else {			return background;		}	}	/*Phong Reflection	Illumination = ambient + diffuse + specular	Illum = Ka x I + Kd x I x (cos q) + Ks x I x cos(f)^n	Illum = initAmbient x I + initDiffuse x I x (N.L) + initSpecular x I x (R.V)^shiness */	//have read the article https://blog.csdn.net/weixin_34319111/article/details/88009666?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160284554719195188335379%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=160284554719195188335379&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-4-88009666.first_rank_ecpm_v3_pc_rank_v2&utm_term=%E6%BC%AB%E5%B0%84%E5%85%89%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0&spm=1018.2118.3001.4187	public Color illuminateCalculate(Intersect intersect,Ray r) {		Ray traceback = new Ray(intersect.hitPosition, lightpos.sub(intersect.hitPosition).normalize());		if (shadowRaytrace(traceback,intersect) != background) {			return shadowRaytrace(traceback,  intersect);		}		Color res;		//normalise to calculate		float[] interColor=intersect.color.getColorComponents(null);		float[] lightcolor=lightColor.getColorComponents(null);		P3D interC = new P3D(interColor[0],interColor[1],interColor[2]);		P3D lightC = new P3D(lightcolor[0],lightcolor[1],lightcolor[2]);		//System.out.println(interC);		//get N/L/R/V to calculate---method1		P3D normalVector=intersect.hitNormal;		P3D lightVector=lightpos.sub(intersect.hitPosition).normalize();//start from intersect		P3D reflectVector=normalVector.reflect(lightVector).normalize();//start from intersect		P3D eyeVector=r.position.sub(intersect.hitPosition).normalize();//r is eye,start from intersect		//P3D eyeVector=r.direction.normalize().scale(-1);		P3D vDiffuse=initDiffuse.scale(Math.max(0.0,normalVector.dot(lightVector)));//get rid of the negative value		//P3D vSpecular=initSpecular.scale(Math.max(0.0,Math.pow(reflectVector.dot(eyeVector),shininess)));		//method 2 for diffuse (add luminosity)		/*double lambert= Math.max(normalVector.dot(lightVector),0);		double luminosity = 1 /Math.sqrt(lightpos.sub(intersect.hitPosition).length());*/		//P3D vDiffuse=initDiffuse.scale(lambert*luminosity);		//method 2 for specular use halfvector to calculate		P3D halfVector=lightVector.add(eyeVector).normalize();		double Factor=halfVector.dot(intersect.hitNormal);		double powerFactor=Math.max(0.0,Math.pow(Factor,shininess));		P3D vSpecular=initSpecular.scale(powerFactor);		double illuminateR=Math.min(255,(vAmbient.scale(lightC.x).scale(interC.x).x+vDiffuse.scale(lightC.x).scale(interC.x).x+vSpecular.scale(lightC.x).x)*255);		double illuminateG=Math.min(255,(vAmbient.scale(lightC.y).scale(interC.y).y+vDiffuse.scale(lightC.y).scale(interC.y).y+vSpecular.scale(lightC.y).y)*255);		double illuminateB=Math.min(255,(vAmbient.scale(lightC.z).scale(interC.z).z+vDiffuse.scale(lightC.z).scale(interC.z).z+vSpecular.scale(lightC.z).z)*255);		//System.out.println(illuminateR+","+illuminateG+","+illuminateB+",");		res= new Color((int)illuminateR,(int)illuminateG,(int)illuminateB);		//System.out.println(res);		return res;	}	private double clamp(double r) {		return (r < 0.0 ? 0.0 : (r > 1.0 ? 1.0 : r));	}}