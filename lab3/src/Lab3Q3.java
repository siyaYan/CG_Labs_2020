import java.awt.Dimension;import java.nio.FloatBuffer;import java.nio.IntBuffer;import java.util.Random;import javax.swing.JFrame;import com.jogamp.common.nio.Buffers;import com.jogamp.opengl.GL;import com.jogamp.opengl.GL2;import com.jogamp.opengl.GLAutoDrawable;import com.jogamp.opengl.GLCapabilities;import com.jogamp.opengl.GLEventListener;import com.jogamp.opengl.GLProfile;import com.jogamp.opengl.awt.GLJPanel;import com.jogamp.opengl.glu.GLU;import com.jogamp.opengl.util.FPSAnimator;import com.jogamp.opengl.util.PMVMatrix;import com.jogamp.opengl.util.gl2.GLUT;public class Lab3Q3 implements GLEventListener {	/**	 * Shader2DColorFan - this is a simple example for drawing a fan made up up colored triangles	 * using a shader Eric McCreath 2009, 2011, 2015, 2017, 2019	 * Xiran Yan u7167582	 * change the version of jogl jar to the lastest one(2.4.0),because of the old one have bug with macos.	 *	 * When tested on the lab machines I found it worked okay with:	 *    JRE System Library [java-11-openjdk-amd64]	 *    /usr/share/java/gluegen2-rt.jar	 *    /usr/share/java/jogl2.jar	 *    	 *    In eclipse to add these go to:	 *       Project->Properties->Java Build Path->Libraries	 *           Added the above external jars and set up the system library if	 *           needed.          *           Java 11 can be found at:         *                /usr/lib/jvm/java-11-openjdk-amd64         *           on our lab machines.	 *         	 *    From the command line you should be able to run:	 *    $ javac -cp /usr/share/java/jogl2.jar:/usr/share/java/gluegen2-rt.jar:.  Shader2DColorFan.java	 *    $ java -cp /usr/share/java/jogl2.jar:/usr/share/java/gluegen2-rt.jar:.  Shader2DColorFan    	 *    	 */	JFrame jf;	GLProfile profile;	GLJPanel gljpanel;	GLCapabilities caps;	Dimension dim = new Dimension(800, 600);	FPSAnimator animator;	float size=  400;	float xpos = 0.0f;	float xvel = 1.0f;	PMVMatrix matrix;	int shaderprogram, vertexshader, fragshader;	int vertexbuffer[];	int colorbuffer[];	int texturebuffer[];	public Lab3Q3() {		jf = new JFrame("Shader2DColorFan");		profile = GLProfile.getDefault();		caps = new GLCapabilities(profile);		gljpanel = new GLJPanel();		gljpanel.addGLEventListener(this);		gljpanel.requestFocusInWindow();		jf.getContentPane().add(gljpanel);		jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);		jf.setVisible(true);		jf.setPreferredSize(dim);		jf.setResizable(false);		jf.pack();		animator = new FPSAnimator(gljpanel, 60);		animator.start();	}	public static void main(String[] args) {		new Lab3Q3();	}	// this vertex shader basically applies the model view and projections matricies	static final String vertstr[] = { 			"attribute vec2 aPos;\n" +			"attribute vec3 color;\n" + 	        "uniform mat4 mvMat, pMat;\n" +			"varying vec4 vertex_color;\n" + 			"vec4 mc;\n" + 			"void main() {\n" +			"    vertex_color = vec4(color,1.0);\n" + 			"    mc = vec4(aPos.x,aPos.y,0.0,1.0);\n" +			"    gl_Position = (pMat * mvMat) * mc;\n" + 			"}\n" };	static int vlens[] = new int[1];	static int flens[] = new int[1];	// the fragment shader combines the vertex color is a simple pattern based on the texture coordinate.	static final String fragstr[] = { 			"varying vec4 vertex_color;\n" +			"void main() {\n" +		    "   gl_FragColor = vec4(vertex_color.x,vertex_color.y,vertex_color.z,1.0);\n" +			"}\n" };	float[] triangleArray = new float[64 * 6 * 2];	float[] triangleColorArray = new float[128 * 3 * 3];	public void init(GLAutoDrawable dr) { // set up openGL for 2D drawing		GL2 gl2 = dr.getGL().getGL2();		GLU glu = new GLU();		GLUT glut = new GLUT();		System.out.println("GL_VERSION : " + gl2.glGetString(GL2.GL_VERSION));		System.out.println("GL_SHADING_LANGUAGE_VERSION : " + gl2.glGetString(GL2.GL_SHADING_LANGUAGE_VERSION));		matrix = new PMVMatrix();		// setup and load the vertex and fragment shader programs		matrix.glMatrixMode(GL2.GL_PROJECTION);		matrix.glOrthof(0.0f, (float) dim.getWidth(), 0.0f, (float) dim.getHeight(), -1.0f, 1.0f);		// matrix.glOrthof(-2.0f, 2.0f, -2.0f, 2.0f, -1.0f, 1.0f);		// matrix.glFrustumf(-2.0f, 2.0f, -2.0f, 2.0f, 1.0f, 10.0f);		matrix.glMatrixMode(GL2.GL_MODELVIEW); 		// setup and load the vertex and fragment shader programs		shaderprogram = gl2.glCreateProgram();		vertexshader = gl2.glCreateShader(GL2.GL_VERTEX_SHADER);		vlens[0] = vertstr[0].length();		gl2.glShaderSource(vertexshader, 1, vertstr, vlens, 0);		gl2.glCompileShader(vertexshader);		checkcompileok(gl2, vertexshader, GL2.GL_COMPILE_STATUS);		gl2.glAttachShader(shaderprogram, vertexshader);		fragshader = gl2.glCreateShader(GL2.GL_FRAGMENT_SHADER);		flens[0] = fragstr[0].length();		gl2.glShaderSource(fragshader, 1, fragstr, flens, 0);		gl2.glCompileShader(fragshader);		checkcompileok(gl2, fragshader, GL2.GL_COMPILE_STATUS);		gl2.glAttachShader(shaderprogram, fragshader);		gl2.glLinkProgram(shaderprogram);		checkok(gl2, shaderprogram, GL2.GL_LINK_STATUS);		gl2.glValidateProgram(shaderprogram);		checkok(gl2, shaderprogram, GL2.GL_VALIDATE_STATUS);		// load the vertex and color data for drawing the triangles		// draw the 64 white triangle		float cr = 1;float cg = 1;float cb = 1;		//every loop draw 2 triangles		int i=0;		for (int j = 0; j < 400/50; j++) {			for (int k = 0; k < 400/100; k++) {				//even line(j start from 0)				if (j % 2 != 0) {					//2 white triangle					triangleArray[12 * i + 0] = 50.0f + k*100;					triangleArray[12 * i + 1] = 0.0f + j*50;					triangleArray[12 * i + 2] = 100 + k*100;					triangleArray[12 * i + 3] = 0.0f+ j*50;					triangleArray[12 * i + 4] = 50.0f + k*100;					triangleArray[12 * i + 5] = 50.0f+ j*50;					triangleArray[12 * i + 6] = 100.0f + k*100;					triangleArray[12 * i + 7] = 50.0f+ j*50;					triangleArray[12 * i + 8] = 50 + k*100;					triangleArray[12 * i + 9] = 50.0f+ j*50;					triangleArray[12 * i + 10] = 100.0f + k*100;					triangleArray[12 * i + 11] = 0.0f+ j*50;					//2 black triangle					triangleArray[12 * (i+1) + 0] = 0.0f + k*100;					triangleArray[12 * (i+1) + 1] = 0.0f + j*50;					triangleArray[12 * (i+1) + 2] = 50+ k*100;					triangleArray[12 * (i+1) + 3] = 0.0f+ j*50;					triangleArray[12 * (i+1) + 4] = 0.0f+ k*100;					triangleArray[12 * (i+1) + 5] = 50.0f+ j*50;					triangleArray[12 * (i+1) + 6] = 50.0f+ k*100;					triangleArray[12 * (i+1) + 7] = 50.0f+ j*50;					triangleArray[12 * (i+1) + 8] = 0+ k*100;					triangleArray[12 * (i+1) + 9] = 50.0f+ j*50;					triangleArray[12 * (i+1) + 10] = 50.0f+ k*100;					triangleArray[12 * (i+1) + 11] = 0.0f+ j*50;				}				//odd line				else {					triangleArray[12 * i + 0] = 0.0f + k*100;					triangleArray[12 * i + 1] = 0.0f + j*50;					triangleArray[12 * i + 2] = 50+ k*100;					triangleArray[12 * i + 3] = 0.0f+ j*50;					triangleArray[12 * i + 4] = 0.0f+ k*100;					triangleArray[12 * i + 5] = 50.0f+ j*50;					triangleArray[12 * i + 6] = 50.0f+ k*100;					triangleArray[12 * i + 7] = 50.0f+ j*50;					triangleArray[12 * i + 8] = 0+ k*100;					triangleArray[12 * i + 9] = 50.0f+ j*50;					triangleArray[12 * i + 10] = 50.0f+ k*100;					triangleArray[12 * i + 11] = 0.0f+ j*50;					triangleArray[12 * (i+1) + 0] = 50.0f + k*100;					triangleArray[12 * (i+1) + 1] = 0.0f + j*50;					triangleArray[12 * (i+1) + 2] = 100 + k*100;					triangleArray[12 * (i+1) + 3] = 0.0f+ j*50;					triangleArray[12 * (i+1) + 4] = 50.0f + k*100;					triangleArray[12 * (i+1) + 5] = 50.0f+ j*50;					triangleArray[12 * (i+1) + 6] = 100.0f + k*100;					triangleArray[12 * (i+1) + 7] = 50.0f+ j*50;					triangleArray[12 * (i+1) + 8] = 50 + k*100;					triangleArray[12 * (i+1) + 9] = 50.0f+ j*50;					triangleArray[12 * (i+1) + 10] = 100.0f + k*100;					triangleArray[12 * (i+1) + 11] = 0.0f+ j*50;				}				i=i+2;			}		}		for (int k = 0; k < 128; k=k+4) {			//2 white triangle			cr = 1;cg = 1;cb = 1;				triangleColorArray[9*k + 0] = cr;				triangleColorArray[9*k + 1] = cg;				triangleColorArray[9*k + 2] = cb;				triangleColorArray[9*k + 3] = cr;				triangleColorArray[9*k + 4] = cg;				triangleColorArray[9*k + 5] = cb;				triangleColorArray[9*k + 6] = cr;				triangleColorArray[9*k + 7] = cg;				triangleColorArray[9*k + 8] = cb;				triangleColorArray[9*(k+1) + 0] = cr;				triangleColorArray[9*(k+1) + 1] = cg;				triangleColorArray[9*(k+1) + 2] = cb;				triangleColorArray[9*(k+1) + 3] = cr;				triangleColorArray[9*(k+1) + 4] = cg;				triangleColorArray[9*(k+1) + 5] = cb;				triangleColorArray[9*(k+1) + 6] = cr;				triangleColorArray[9*(k+1) + 7] = cg;				triangleColorArray[9*(k+1) + 8] = cb;			//2 black triangle				cr = 0;cg = 0;cb = 0;				triangleColorArray[9*(k+2) + 0] = cr;				triangleColorArray[9*(k+2) + 1] = cg;				triangleColorArray[9*(k+2) + 2] = cb;				triangleColorArray[9*(k+2) + 3] = cr;				triangleColorArray[9*(k+2) + 4] = cg;				triangleColorArray[9*(k+2) + 5] = cb;				triangleColorArray[9*(k+2) + 6] = cr;				triangleColorArray[9*(k+2) + 7] = cg;				triangleColorArray[9*(k+2) + 8] = cb;				triangleColorArray[9*((k+2)+1) + 0] = cr;				triangleColorArray[9*((k+2)+1) + 1] = cg;				triangleColorArray[9*((k+2)+1) + 2] = cb;				triangleColorArray[9*((k+2)+1) + 3] = cr;				triangleColorArray[9*((k+2)+1) + 4] = cg;				triangleColorArray[9*((k+2)+1) + 5] = cb;				triangleColorArray[9*((k+2)+1) + 6] = cr;				triangleColorArray[9*((k+2)+1) + 7] = cg;				triangleColorArray[9*((k+2)+1) + 8] = cb;		}		FloatBuffer triangleVertexBuffer = Buffers.newDirectFloatBuffer(triangleArray);		FloatBuffer triangleColorBuffer = Buffers.newDirectFloatBuffer(triangleColorArray);		// set up the buffers on the GPU		vertexbuffer = new int[1];		gl2.glGenBuffers(1, vertexbuffer, 0);		gl2.glBindBuffer(GL2.GL_ARRAY_BUFFER, vertexbuffer[0]);		gl2.glBufferData(GL2.GL_ARRAY_BUFFER, (long) triangleArray.length * 4, triangleVertexBuffer,				GL2.GL_STATIC_DRAW);		colorbuffer = new int[1];		gl2.glGenBuffers(1, colorbuffer, 0);		gl2.glBindBuffer(GL2.GL_ARRAY_BUFFER, colorbuffer[0]);		gl2.glBufferData(GL2.GL_ARRAY_BUFFER, (long) triangleColorArray.length * 4, triangleColorBuffer,				GL2.GL_STATIC_DRAW);		gl2.glUseProgram(shaderprogram);		// make the background blue		gl2.glClearColor(0.0f, 0.0f, 1.0f, 0.0f);	}	private void checkok(GL2 gl2, int program, int type) {		IntBuffer intBuffer = IntBuffer.allocate(1);		gl2.glGetProgramiv(program, type, intBuffer);		if (intBuffer.get(0) != GL.GL_TRUE) {			int[] len = new int[1];			gl2.glGetProgramiv(program, GL2.GL_INFO_LOG_LENGTH, len, 0);			if (len[0] != 0) {				byte[] errormessage = new byte[len[0]];				gl2.glGetProgramInfoLog(program, len[0], len, 0, errormessage, 0);				System.err.println("problem\n" + new String(errormessage));				gljpanel.destroy();				jf.dispose();				System.exit(0);			}		}	}	private void checkcompileok(GL2 gl2, int program, int type) {		IntBuffer intBuffer = IntBuffer.allocate(1);		gl2.glGetShaderiv(program, GL2.GL_COMPILE_STATUS, intBuffer);		if (intBuffer.get(0) == GL.GL_FALSE) {			int[] len = new int[1];			gl2.glGetShaderiv(program, GL2.GL_INFO_LOG_LENGTH, len, 0);			if (len[0] != 0) {				byte[] errormessage = new byte[len[0]];				gl2.glGetShaderInfoLog(program, len[0], len, 0, errormessage, 0);				System.err.println("problem\n" + new String(errormessage));				gljpanel.destroy();				jf.dispose();				System.exit(0);			}		}	}	public void display(GLAutoDrawable dr) { 		GL2 gl2 = dr.getGL().getGL2();		GLU glu = new GLU();		GLUT glut = new GLUT();		gl2.glUseProgram(shaderprogram);		gl2.glClear(GL.GL_COLOR_BUFFER_BIT);		// connect the buffers with input attributes within the shader		int posVAttrib = gl2.glGetAttribLocation(shaderprogram, "aPos");		gl2.glEnableVertexAttribArray(posVAttrib);		gl2.glBindBuffer(GL2.GL_ARRAY_BUFFER, vertexbuffer[0]);		gl2.glVertexAttribPointer(posVAttrib, 2, GL2.GL_FLOAT, false, 0, 0);		int posCAttrib = gl2.glGetAttribLocation(shaderprogram, "color");		gl2.glEnableVertexAttribArray(posCAttrib);		gl2.glBindBuffer(GL2.GL_ARRAY_BUFFER, colorbuffer[0]);		gl2.glVertexAttribPointer(posCAttrib, 3, GL2.GL_FLOAT, false, 0, 0);		//  set up the matricies		matrix.glPushMatrix();		//rotate the chess board		matrix.glTranslatef((float) (dim.getWidth())/2,(float) (dim.getHeight())/2,0);		matrix.glRotatef(xpos,0,0,1);		matrix.glTranslatef((float) -(dim.getWidth())/2,(float) -(dim.getHeight())/2,0);		//move to center		matrix.glTranslatef((dim.width-size) / 2.0f, (dim.height-size) / 2.0f, 0.0f);		int mvMatrixID = gl2.glGetUniformLocation(shaderprogram, "mvMat");		gl2.glUniformMatrix4fv(mvMatrixID, 1, false, matrix.glGetMvMatrixf());		int pMatrixID = gl2.glGetUniformLocation(shaderprogram, "pMat");		gl2.glUniformMatrix4fv(pMatrixID, 1, false, matrix.glGetPMatrixf());		// do the actual drawing(128 triangles)		gl2.glDrawArrays(GL2.GL_TRIANGLES, 0, 128*3);		matrix.glPopMatrix();		gl2.glDisableVertexAttribArray(posVAttrib);		gl2.glDisableVertexAttribArray(posCAttrib);		gl2.glFlush();		//chang the rotate index		xpos += xvel;		if (xpos > 360)			xpos = 0.0f;	}	public void dispose(GLAutoDrawable glautodrawable) {	}	public void reshape(GLAutoDrawable dr, int x, int y, int width, int height) {	}}