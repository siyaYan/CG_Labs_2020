import java.awt.Color;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import javax.imageio.ImageIO;/* Texture - stores infor about a loaded texture.  * Eric McCreath 2019 * @author Xiran Yan * @UID  u7167582 * */public class Texture extends Item {	BufferedImage image;	int width, height;	P3D position;	P3D widthVector;	P3D highVector;	int[] rgb = new int[3];	Color color;	public Texture(String name,P3D position,P3D widthVector,P3D highVector) {		try {			image = ImageIO.read(new File(name));			this.position=position;			this.widthVector=widthVector;			this.highVector=highVector;			width = image.getWidth();			height = image.getHeight();			//System.out.println("image:"+width+","+height);		} catch (IOException e) {			e.printStackTrace();			System.exit(1); // lets just fail if the texture fails to load		}	}	@Override	public Intersect intersect(Ray ray) {		P3D normal=widthVector.cross(highVector).normalize();		P3D interPlane;		double dis;		P3D colorPos;		// not parallel		if (normal.dot(ray.direction) != 0) {			/*get some idea for calculate,but didn't copy it			https://www.jianshu.com/p/f7aa8b531487?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation			*/			//step1,judge whether is in the plane,get the intersect with the plane			double t=position.sub(ray.position).dot(normal)/(ray.direction.dot(normal));//t is the scale for length			//plane is behind the ray			if (t < 0) {				return null;			}			interPlane=ray.position.add(ray.direction.normalize().scale(t));//p = pO + t*Direction*			//1,2,3,4 are 4 corner of the rectangl;v1,v2,v3,v4 are four vector from corner point to interPlane			P3D v1=interPlane.sub(position);			P3D v4=interPlane.sub(position.add(highVector));			P3D v2=interPlane.sub(position.add(widthVector));			P3D v3=interPlane.sub(position.add(widthVector).add(highVector));			//step 2, judge if the point is inside of the rec(for all 4 lines)			if (v1.dot(highVector) > 0 && v2.dot(widthVector.scale(-1)) > 0 && v3.dot(highVector.scale(-1)) > 0 && v4.dot(widthVector) > 0) {				dis=interPlane.sub(ray.position).length();				colorPos= interPlane.sub(position);				//calculate the texture color method1 (width/widthVector=Texturepoint.x/colorPos.x)				/*color= new Color(image.getRGB((int)(width*colorPos.x/widthVector.length()),(int)(height*colorPos.y/highVector.length())));				System.out.println(colorPos);*/				//get the texture color method2				double u=colorPos.x/widthVector.length();				double v=colorPos.y/highVector.length();				color=lookup(u, v);				return new Intersect(dis, interPlane, normal, this, color);			} else {				return null;			}		}		return null;	}	// lookup - look up the colour of a particular texture coordinate.	public Color lookup(double u, double v) {		if (0.0 <= u && u <= 1.0 && 0.0 <= v && v <= 1.0) {			return new Color(					image.getRGB((int) Math.floor(u * (width - 1)), height - ((int) Math.floor(v * (height - 1))) - 1));		} else {			return Color.BLACK;		}	}}